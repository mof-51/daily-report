# 取り組んだ課題一覧
- 【継続】ホームポジションでのタイピング練習(30分)
- Git & GitHub
	- 【完了】Git： もう怖くないGit！チーム開発で必要なGitを完全マスター | Udemy(セクション7から)

# わかったこと
- プルリクエスト
	- 自分の変更をレビューしリポジトリに取り込んでもらうよう依頼する機能
	- 手順
		1. ワークツリーを最新に更新
		2. プルリクエストを送るためのブランチを作成：`git checkout -b pull_request`=`git checkout -b プルリクエスト用のリポジトリ`
		3. ファイルを変更：`git add index.html`=`git add 変更したファイル名`
		4. ローカルリポジトリに変更をコミット：`git commit`
		5. GitHubへプッシュ：`git push origin pull_request`=`git push origin プルリクエスト用のリポジトリ`
		6. プルリクエストを送る
			1. ブラウザでGitHubの対象のリポジトリに移動し、Pull requestsタブを開く
			2. New pull requestをクリック
			3. baseは基盤(統合元)のブランチなのでmainを選択、compareはプルリクエストするブランチなのでpull_requestを選択しCreate pull requestをクリック
			4. タイトルはコミット時に記載したコメントが反映される。本文は「レビューをお願いします」などレビューする人に向けたメッセージを記載する。Create pull requestをクリック
			5. Reviewersをクリックしコードレビューを依頼する人を選択→レビュアーにメールで通知がいく
		7. チームメンバーがコードレビューを実施(レビューする側の操作)
			1. pull requestsタブを開きFile changedタブをクリック
		 	2. +マークと背景色で変更箇所がわかる。追加で修正してほしいところがある場合はその行の+をクリックし、Writeのところに修正内容を記載しAdd single commentをクリック→プルリクエストを送った人に通知がいく(修正→プルリクエストを何度か繰り返すことでコードレビューが完了する)
		8. 内容がOKであればプルリクエストをマージ(レビューする側の操作)
			1. Review changes→Approveをクリック
		 	2. pull requestsタブを開き、Merge pull requestをクリック→Confirm mergeをクリック
		9. プルリクエスト用に作成したブランチを削除
			1. pull requestsタブ→ConversationタブのDelete branchでpull_requestブランチを削除
		 	2. `git branch -d pull_request`でローカルのプルリクエスト用のブランチも削除
		10. リモートリポジトリの内容をワークツリーに反映：`git pull origin main`

- GitHub Flow
	- GitHub社のワークフロー
	- 特徴
		- 開発フローがシンプルで誰でもジョインできる
		- 機能完成→即時デプロイなので、今リリースされている状態を把握できる
		- 機能単位で細かくデプロイしているので、もしバグが見つかってもすぐに切り戻せる
	- ポイント
		- masterブランチは常にデプロイできる状態に保つ
		- 新しい開発はmasterブランチから新しいブランチを作成してスタートし、作業はコミットまですべてそのブランチで行う
		- 定期的にプッシュする(チームメンバーが進捗を把握できるため)
		- masterにマージする時はプルリクエストを送る(必ずレビューを通す)
		- masterブランチにマージしたらすぐにデプロイする(テストとデプロイの作業は自動化しておく)
  - 開発の流れ
	  - masterブランチからブランチを作成
	  - ファイルを変更しコミット
	  - コミットしたブランチをGitHubへプッシュ
	  - プルリクエストを送る
	  - コードレビューをしてもらい、masterブランチにマージ
	  - masterブランチをデプロイ
   
- リベース
	- 履歴を一直線に整えつつマージする=ペアレントが変わる
	- リベース後分岐していたブランチの履歴は消える
	- **GitHubにプッシュしたコミットをリベースするのは絶対NG**
	- コマンド：`git rebase メインブランチ名`
	- 手順
		1. `git checkout`で分岐ブランチに移動する
		2. `git rebase メインブランチ名`でリベース=分岐ブランチの親がメインブランチの最新のコミットになり、その内容が反映されたコミットができる
		3. メインブランチに移動する
		4. メインブランチを分岐ブランチにマージする
	- マージとリベースの違い
		- マージ：分岐したブランチの履歴が全て残る。コンフリクトが起きた際に1ファイルの修正で済む。
  	- リベース：分岐しブランチを統合した後は、分地したブランチの履歴は残らない。コンフリクトが起きた時にペアレントファイルのコンフリクトも解消する必要があるのでやや面倒。

- プルのリベース型
	- マージコミットが残らないため、GitHubの情報を取得したいだけ(何かを変更するわけではないのでコミットを残す必要がない)ならリベース型がおすすめ
	- コマンド：`git pull --rebase origin main`=`git pull --rebase リモート名 ブランチ名`
	- pullはデフォルトでリベースにする場合の設定：`git config --global pull.rebase true`→設定済、今後`--rebase`は不要

- 複数のコミットを修正する(プッシュ前のもののみ)
	- コマンド
		- `git rebase -i コミットID`：特定のコミットIDを修正
		- `git rebase -i HEAD~3`：直前3つのコミットを修正。古い順に表示される
  - 手順
		1. `git rebase -i(--interactive)`で対話的リベースモードに入る
		2. エディタが立ち上がるので、修正したいコミットの`pick`を`edit`にして保存しエディタを終了する。
		3. ファイルの内容を修正したい場合は修正し`it commit --amend`を実行
		4. コメントを修正したい場合はここで立ち上がったエディタで修正
		5. `git rebase --continue`で次のコミットへ移動→他に`edit`に変更したものがなければ`pick`のものはスルーされ、自動的に対話的リベースモードが終了する

- コミットの順番を入れ替える
	- コマンド
		- `git rebase -i HEAD~3`：直前3つのコミットを修正。古い順に表示される
  - 手順
		1. `git rebase -i(--interactive)`で対話的リベースモードに入る
		2. エディタが立ち上がるので、コミットを任意の順番に入れ替えて保存する

-	 コミットを1つにまとめる
	- コマンド
		- `git rebase -i HEAD~3`：直前3つのコミットを修正。古い順に表示される
  - 手順
		1. `git rebase -i(--interactive)`で対話的リベースモードに入る
		2. エディタが立ち上がるので、統合先のコミットは`pick`のまま残し、統合したいコミットを`squash`にして保存しファイルを閉じる
    3. 再度エディタが立ち上がる。コミットをまとめたというコメントが自動的に入るため、そのままで良ければ保存しファイルを閉じる。コメントを編集したい場合は修正・保存しファイルを閉じる。

- コミットを分割する
	- コマンド
		- `git rebase -i HEAD~3`：直前3つのコミットを修正。古い順に表示される
	- 手順
		1. `git rebase -i(--interactive)`で対話的リベースモードに入る
		2. エディタが立ち上がるので、分割したいコミットを`edit`にして保存しファイルを閉じる
		3. `git reset HEAD^`でHEADのひとつ前のコミットを取り消しステージングにもない状態にする
		4. `git add ファイル名`で分割したい分のファイルを追加、`git commit`でコミット
		5. 上記の操作でさらに分割したいファイルを追加しコミット
		6. `git rebase --continue`で次のリベースへ進む

- タグ
	- コミットを参照しやすくするためにつけるもの。リリースポイントにつけることが多い
	- 注釈付タグ(annotated)と軽量版タグ(lightweight)がある
		- 注釈付きタグ：タグ名・コメント・署名(自動)が付けられる
		- 軽量版タグ：タグ名のみ付けられる
	- コマンド
		- `git tag -a 20170520_01 -m "Version 20170520_01"`=`git tag -a タグ名 -m "メッセージ"`：注釈付きタグを作成する
  	- `git tag 20170520_01`=`git tag タグ名`：軽量版タグを作成する
		- `git tag`：アルファベット順で作成済みのすべてのタグを表示する
		- `git show 20170520`=`git show タグ名`：タグのデータと関連付けられたコミットを表示する
			- オプション
				- `-l "2017"`=`-l パターン`：タグ名の一部を入力すると該当するタグのデータと関連付けられたコミットの一覧を表示する
  - タグをリモートリポジトリに送信する
	  - コマンド：`git push origin 201705`=`git push リモート名 タグ名`
	  - オプション
			- `--tags`：リモートリポジトリにないタグをすべて送信する。例)`git push origin --tags`

- 作業を一時避難する
	- コミットはしないが緊急で別の作業をしなければいけなくなった時などに、現在の作業分をstashに一時避難させる
 - スタッシュ名の番号は新しいスタッシュが0になり、スタッシュが増えていくと0が最新のスタッシュ、数字が大きい方が古いスタッシュになる
	- コマンド
		- `git stash`または`git stash save`(saveは省略可なので２つのコマンドは同じ)：作業内容を一時避難させる
	  - `git stash list`：一時避難させた作業を確認する
		- `git stash apply`：避難した作業内容をワークツリーに復元する
			- オプション
				- `--index`：ステージの状況も復元する
    - `git stash apply stash@{1}`=`git stash apply スタッシュ名`：避難した特定の作業内容を復元する
    - `git stash drop`：最新のスタッシュを削除する
    - `git stash drop stash@{1}`=`git stash drop スタッシュ名`：特定の作業を削除する
		- `git stash clear`：全作業を削除する

# 次やること
- Git & GitHub
	- Gitによるバージョン管理
	- `git pull`ができなかった理由はわかったけど詳しく調べたい
- manコマンドを日本語化(必要性があると判断したので優先度を上げます。時間を作る)

# 感じたこと
- リベースの理解がむずかしかったがたぶん理解できたと思う。
- 操作しながら学習を進めたので、気分的にはGitが使えるようになった感じ。もっといろいろあると思うので、引き続きGitmの学習を継続していく。
- そろそろ何かアウトプットしたい。

# 学習時間
Today：6h Total：165.75h
