# 取り組んだ課題一覧
- HTML/CSS
	- アウトプット課題
		- プルリクでimagesフォルダがFile changedに表示されない問題を解消しコメント返信 → 待ち
- SQL
	- SQL超入門コース(目次09の途中から18まで)

# 課題以外で取り組んだこと
- ホームポジションでのタイピング練習
	- 毎日10分継続

# わかったこと
## PostgreSQL
- インストール
	1. ターミナルで`brew install postgresql`を実行
	1. `psql --version`でインストールできたかを確認

- ユーザ名とパスワードの設定
	1. `postgres -D /usr/local/var/postgresql@バージョン`でPostgreSQLを起動
	1. `createuser -P workuser`でユーザを作成(`workuser`部分は任意の名前でOK)
	1. パスワードを設定→再入力

- データベースへの接続
	1. `psql -l`で今あるデータベースを確認
	1. `psql -d データベース名`で接続(データベース名はName列のもの)

- 権限の確認と付与
	1. `postgres=#`の後ろに`\du`でユーザ一覧を確認
	1. `ALTER ROLE workuser CREATEDB;`でデータベースの作成権限を付与 → `\du`で権限が付与されたか確認

- バックアップの作成
	- コマンド：`pg_dump postgres > /Users/dpcrosse/Desktop/test_db`=`pg_dump データベース名 > ディレクトリ名/ファイル名`

- リストア
	- バックアップファイルからデータを復元すること
	- リストアする際は先にデータベースを作成しておく必要がある
	- コマンド：`psql test_db < /Users/dpcrosse/Desktop/test_db`  
	= `psql 作成するデータベース名 < dumpファイル名`

- データベースの切断
	- `\q`

- PostgreSQLの終了
	- `ctrl + c`

## pgAdmin 4
- 接続名の作成
	1. Object ExplorerのServersを右クリック
	1. Register > Server...をクリック
	1. Genetalタブ > Nameに接続名を入力(例：test1)
	1. Connectionタブ > Host name/addressに`127.0.0.1`を設定(ローカルホスト)
	1. UsernameとPasswordにPostgreSQLで作成したユーザ名とパスワードを入力し、Save passwordにチェックを入れてSave
	→左に作成した接続名が表示されていたらOK

- データベースの作成
	1. 作成した接続名左の`>`をクリック
	1. Databasesを右クリック、Create > Database...をクリック
	1. Generalタブ > Databaseに任意のデータベース名を入力しSave(例：test_database)
	1. 作成したデータベース名の`>`をクリック > Schemasの`>`をクリック > Tablesを右クリック > Create > Table...をクリック
	1. Generalタブ > Nameに任意のテーブル名を入力(例：test_table)
	1. Columnsタブ > 右上の`+`でカラムを追加  
→ 作成したテーブルがtablesの配下に表示されていればOK

- データの登録
	1. 作成したテーブルを右クリック > Import/Export dataをクリック
	1. Generalタブ > Filenameでインポートするファイルを選択
	1. FormatとEncoding(UTF8)を指定
	1. Optionsタブ > HeaderをONにしOKをクリック

- インポートしたデータの確認
	1. 作成したテーブル名を右クリック
	1. View/Edit Data > All Rowsをクリック  
	→ インポートしたデータが表示されていればOK

- SQLの記述
	1. テーブル名を右クリックしQuery Toolをクリック
	1. SQLを記述、右上の再生ボタンをクリックし実行

- データベースのバックアップ
	- dumpといい、データベースのバックアップを取ることを「データベースをdumpする」という
	- dumpで作成したファイルを**dumpファイル**という

## LIKE演算子
- 種類：前方一致, 後方一致, 部分一致, 完全一致
- ワイルドカードを使用
		- `_`：任意の文字列一文字
		- `%`：0文字以上の任意の文字列

- 特定の文字列を**含む**レコードを抽出
	```基本構文
	where カラム名 like 'パターンマッチングの条件'
	```

	```前方一致
	/* 例） Aで始まる何文字かの文字列 */
	where カラム名 like 'A%'

	/* 例） Aで始まる5文字の文字列 */
	where カラム名 like 'A____'
	```

	```後方一致
	/* 例） Aで終わる何文字かの文字列 */
	where カラム名 like '%A'

	/* 例） Aで終わる5文字の文字列 */
	where カラム名 like '____A'
	```

	```　前方一致と後方一致の両方
	/* 例） Aで始まりZで終わる何文字かの文字列 */
	where カラム名 like 'A%Z'

	/* 例） Aで始まりZで終わる5文字の文字列 */
	where カラム名 like `A___X`
	```

	```　部分一致
	/* 例） Aがどこかに含まれる文字列 */
	where カラム名 like %A%

	/* 例） Aが5文字目に含まれる文字列 */
	where カラム名 like `____A%`
	```

- 特定の文字列を**含まない**レコードを抽出
	- `NOT LIKE`とすることで**指定した文字列を含まない**検索ができる
		```基本構文
		where カラム名 not like 'パターンマッチングの条件'
		```
	- 記述方法は`LIKE`と同じ

- 特殊文字(`%`や`_`)を文字列として検索したい場合
	- エスケープ処理が必要
	- 特殊文字の直前にエスケープ文字を入れ、エスケープ文字として明示する
		```エスケープ処理
		/* 「_A」を文字列として検索 */
		where カラム名 like '?_A' escape '?'
		```
## BETWEEN
- 範囲指定で使用(数値, 日付, 時間, 文字列)
- 可読性が上がる
- 処理速度が上がる
- 以下はどちらも同じ
    ```不等号バージョン
    WHERE カラム名 >= 下限値 AND カラム名 <= 上限値
    ```
    ```betweenバージョン
    WHERE カラム名 BETWEEN 下限値 AND 上限値
    ```

- 「範囲内の」レコードを抽出
	```基本構文
	WHERE カラム名 BETWEEN 下限値 AND 上限値
	```

	```例：商品価格が5000円以上10000円以下の検索
	WHERE 商品価格 BETWEEN 5000 AND 10000
	```

- 「範囲外の」レコードを抽出
	- `NOT BETWEEN`とすることで指定した範囲に該当しないレコードの検索ができる
		```基本構文
		WHERE カラム名 NOT BETWEEN 下限値 AND 上限値
		```
		```例：商品価格が5000円未満10001円以上の検索
		WHERE 商品価格 NOT BETWEEN 5000 AND 10000
		```

## LENGTH関数
- `LENGTH(引数)`で指定
- `SELECT`でも`WHERE`でも使用できる

- 使用できるデータ型
	- 文字列：文字数
	- BLOB型(バイナリデータの格納に使用されるデータ型, 画像などのマルチメディアオブジェクトをバイナリデータに変換したもの)：バイト数
	- 上記以外：文字列型に変換した文字数
	- NULL：NULL
	- SELECT句で使用
		```商品名と商品名の文字数を取得し、文字数は「文字数」というカラム名で表示する
		SELECT 商品名, LENGTH(商品名) 文字数
		```

	- WHERE句で使用
		```商品名が5文字以上のレコードを抽出し、商品名と文字数を表示する
		SELECT 商品名, LENGTH(商品名) 文字数
		FROM test_table
		WHERE LENGTH(商品名) >= 5
		```
## DISTINCT関数
- 重複したレコードを排除してカラムを抽出する
- 複数カラムを対象にした場合はすべてのカラムで一意の組み合わせのレコードのみ抽出される
- `count`関数と組み合わせてレコードの種類を数えることも可能
- `group by`も重複を表示しないので実行結果は同じだが、内部の処理が異なる
	- `group by`：重複をひとつにまとめる
	- `distinct`：重複を削除する  
	→ ただし`distinct`はあくまでレコードの重複に関して指示を出し抽出する関数のため、`SUM`など集計関数が絡む処理は不向き  
	計算が絡む場合は`group by`を使用する

```基本構文
select distinct カラム名
```

```複数カラム指定
select distinct カラム名1, カラム名2
```

```count関数との組み合わせ
select count(distinct カラム名)
```

## SUBSTRING関数
- 対象の文字列から**開始位置**と**文字数**を切り出す
- 第一引数にカラム名、第二引数に抽出文字の開始位置、第三引数に文字数を指定する
- 第二引数は整数のみ
- 第二引数をマイナス値で指定した場合は**文字列を後ろから数えて何番目か**となる  
(マイナス値が指定できないデータベースもあり)
- 文字数が開始位置から最後までを指定する場合は第三引数は省略可
- データベースによって関数名や関数名や文法が異なり`SUBSTR`と記述するデータベースもある

```基本構文
where substring("カラム名", 開始位置, 文字数)
```

- 例1：社員IDの下2桁が00から20の間のデータを抽出する
    ```
    /* 社員IDは4桁と仮定 */
    where substring("社員ID", 3, 2) between '00' and '20'
    ```
    → **社員ID**の**3番目の文字列**から**2桁**が00から20の間のレコードを抽出

- 例2：**売上日の年月ごと**の**売上金額の合計**のデータを抽出する
    ```
    /* 売上日はyyyy-mm-dd形式と仮定 */
    select substring("売上日", 1, 7) as 年月, sum("売上金額") as 売上合計
    from test_table
    group by 年月
    ```
    → 売上日の**1番目の文字列(年の開始文字)** から **7桁(月の終了文字)** のレコードを抽出し、**売上金額を合計**し、**年月ごとにグルーピング**して表示

# 次やること
- SQL
	- SQL超入門コース(目次19から)
- Web開発の基礎を学ぶ [^*]
	- Udemy動画(セクション11の158から)
	[^*] ：業務でSQLを使用することになったため一旦ステイ

# 感じたこと
- Slackのtimesで時々環境構築が大変というのを見かけるが少し気持ちがわかった気がする。
- Progateで学習していた時よりも濃い内容で楽しい。
- メモをまとめながらだと時間がかかる。頭の中を素早く整理して言語化できるようにしたい。

# 学習時間
Today：8h Total：251.5h