# 取り組んだ課題一覧
- JavaScript(ES6) I〜VII

# わかったこと
## 基本
- コンソールに出力する際は`console.log();`を使う。文字列を出力：括弧内でシングルクォーテーションかダブルクォーテーションで文字列を囲う。数値(四則演算)や変数を出力：括弧内にそのまま書く
- 文字列同士を連結して出力する際は文字列同士を+で繋ぐ
- 文字列を変数や定数を連結して出力する際は文字列はダブルクォーテーションで囲わずそのまま書き、変数や定数を`${}`で囲う。また、その場合は出力したいテキスト全体をバッククォーテーションで囲う
- `//`でコメントアウト
- 文の最後はセミコロン必須

## 変数
- `let 変数名 = 値;`で代入
- 変数名は、代入している値が何かわかりやすい名前をつける。数字開始・ローマ字・日本語はNG
- すでにある変数に再度値を代入し上書きすることができる。その場合は`let`は不要で`変数名 = 値;`で代入

## 定数
- 変数に対し、値を再度代入することができない。誤って値を上書きしてしまうリスクを防ぐ
- `const 変数名 = 値;`で代入

## if文(条件分岐)
- if文の中で条件を指定し、返ってきた真偽値によって処理が変わる
- 基本形
	```
	if (Aの条件){
		Aの条件がtrueの時に実施される処理
	} else if(Bの条件) {
		Bの条件がtrueの時に実施される処理
	} else {
		すべての条件がfalseの時に実施される処理
	}
	```
- 真偽値：条件に一致するかどうか。一致する場合はtrueが返り処理が実行される。一致しない場合はfalseが返り処理が実行されない
- 条件の組み合わせ：`if (一つ目の条件 && 二つ目の条件)`でどちらの条件も満たす場合はtrueになる。`if (一つ目の条件 || 二つ目の条件)`でどちらかの条件を満たす場合はtrueになる

## switch文(条件分岐)
- switch文の外で定義したい値に対して処理が実行される
- 基本形
	```
	let 変数名 = 値;
	switch (変数) {
		case "値":
			処理
			break;
		case "値":
			処理
			break;
		default:
			処理
			break;
	}
	```
- if文との使い分け：if文でelse ifが多くなった場合はswitch文で書いた方が見やすい

## while文(繰り返し処理)
- 条件式が満たされるまで処理が繰り返される
- 基本形
	```
	let 変数名 = 値;
	while(条件式){
		処理;
		変数の更新;
	}
	```

## for文(繰り返し処理)
- 条件式が満たされるまで処理が繰り返される
- 基本形
	```
	for(変数定義; 条件式; 変数の更新){
		処理;
	}
	```
- while文よりシンプルに書ける

## 比較演算子
`a === b`でaとbが等しいかどうか、`a !== b`でaとbが等しくないかどうかを調べる

## 配列
- 多数の値を扱う際、値をひとまとめにする。定数に代入して使用する
- 基本形
	```
	定数名 = [値1, 値2, 値3];
	```
- 定数名は複数形にするのが基本
- 配列のインデックス番号は0から始まる。インデックス番号を指定して値を取り出す場合は`定数名[インデックス番号]`
- 配列の中身を上書きする際は変数の上書きと同じ。`定数名[インデックス番号] = 上書きしたい値`
- for文と組み合わせる際、条件式を`配列.length`とすることで、配列の中に入っている値の数が変わっても対応できる

## オブジェクト
- 配列と同じく多数の値を扱う際にひとまとめにするが、配列と異なり「プロパティ」と「値」がセットになっている
- 基本形
	```
	const 定数名 = {プロパティ: 値, プロパティ: 値};
	```
- 値を取り出す場合はプロパティ名を指定する。`定数名: プロパティ名`。同じ書き方で値の上書きが可能

## 関数
- いくつかの処理をまとめたもの
- 「定義」と「実行」の二つが必要
- 基本形(定義)
	```
	const 定数名 = function(){
		処理;
	}
	```
- 基本形(実行)
	`定数名();`
- `function`を略しアロー関数で書くこともできる
	```
	const 定数名 = () => {
		処理;
	}
	```
### 引数
- 関数に引数を指定し関数の実行時に値を渡すことで引数に代入される。引数は複数指定できる
- 基本形
	```
	const 定数名 = (変数名) => {
		処理;
	}

	定数名(値);
	```
- 引数は関数内で定数や変数と同じように使用できる

### 戻り値
- 関数の処理結果を呼び出し元で受け取る
- 基本形
	```
	const 定数名A = (変数名) => { // 関数を定義
		return 処理;
	}

	const 定数名B = 定数名A(値); // 関数を実行
	```
	- `return`には処理を終了する役割もあるため、return以降に処理を記述しても実行されない
	
	### スコープ
	- 定数や変数を使用できる範囲のこと
	- 関数の外側で定義した定数や変数はプログラムのどこでも使用でき、関数内で定義した定数や変数はその定義した関数内でしか使用できない

## クラス
- 設計図。関数を量産する時の雛形のようなもの。クラス名を基本的に大文字で始める。`class クラス名{}`
- インスタンス：クラスを複製した、データが入っていない空の箱`new クラス名();`で作成
- コンストラクタ：インスタンスの中で実行したい処理などを記述する。クラスの中で`constructor(){}`。作成したコンストラクタは、同クラスから作成したインスタンスすべてに適用される
- メソッド：インスタンスの動作？？？
- 継承：作成済みのクラスの中身を丸ごと引き継いで子クラスを作成する。`class 子クラス名 extends 親クラス名{}`
- 親クラスと子クラスで同じメソッド名を定義すると子クラスで定義した方が優先される。これを「オーバーライド」をいう
- コンストラクタもオーバーライドできるが、コンストラクタの場合は冒頭に`super(親クラスと同じ変数名)`を記述する必要がある

## ファイルの分割
- コードの記述量が増えてきた際、保守・管理しやすいようにクラスごとにファイルを分割する
- ファイルに分割したクラスは`export default クラス名;`でエクスポートでき、`import クラス名 from "./そのクラスが記述されているファイル名";`でインポートできる。エクスポート元・インポート先の両方に記述が必要(ファイル名の`.js`は省略可)
- インポートやエクセポートは定数や変数にも適用可能
- `export default`は「デフォルトエクスポート」といい、1ファイル1エクスポートしかできない
- 上記の理由により、インポート時の名前とエクスポート時の名前が異なっても問題なくインポートされる(エクスポート元のファイルからエクスポートされたもの=名前が違ってもそれしかない、という仕組み)
- 1ファイルで複数の値をエクスポートしたい場合は「名前付きエクスポート」を使う。エクスポートする際は`export {値名};`、インポートする際は`import {値名} from "./その値が記述されているファイル名";`。値は複数指定でき`,`で区切る

## パッケージ
- 誰かが作った便利なプログラムセット。インポートすると使用可能になる。インポートしたいファイルの一番上で`import 定数名 from "パッケージ名";`でインポートできる

## pushメソッド
- 配列に要素を追加するメソッド。最後に追加される

## forEachメソッド
- 配列の中身を順番に取得し引数に代入する

## findメソッド
- 配列の中身を順番に取得し、条件式に合う引数に代入、一つ目の要素のみ引数に代入する

## filterメソッド
- 配列の中から条件に合う値をすべて取り出し、取り出した値だけで別の配列を作成する

## mapメソッド
- 配列の中の値すべてに処理をし、新しい配列を作成する

## コールバック関数
- Aの関数の引数に関数を渡すこと。


# 次やること

#感じたこと
文末のセミコロンをよく忘れる。

#今日の「なんで？」ポイント
- switch文もif文同様条件が一致した時しか処理が実行されないのになぜbreak;が重要？caseの書き方によって複数の条件に一致する可能性があるから？
- 戻り値ってどんな時に使うの？どういうシチュエーションでreturnする必要がある？
- `this`ってなに？なぜ必要？＞「メソッド内でインスタンスの値を使用するにはthisという特殊な値を用いて・・」
- コールバック関数とは・・・


#学習時間
Today：h Total：h
